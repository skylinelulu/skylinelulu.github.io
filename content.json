{"meta":{"title":"SkylineLulu","subtitle":null,"description":"在头顶上，有几千亿的光年。","author":"SkylineLulu","url":"https://skylinelulu.github.io"},"pages":[{"title":"tags","date":"2018-05-12T13:20:42.000Z","updated":"2018-06-04T04:35:15.206Z","comments":false,"path":"tags/index.html","permalink":"https://skylinelulu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-12T13:22:49.000Z","updated":"2018-06-04T04:33:30.599Z","comments":false,"path":"categories/index.html","permalink":"https://skylinelulu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Similrity of Android App Methods","slug":"3D-CFG","date":"2018-07-01T07:14:43.000Z","updated":"2018-07-01T08:31:42.117Z","comments":true,"path":"2018/07/01/3D-CFG/","link":"","permalink":"https://skylinelulu.github.io/2018/07/01/3D-CFG/","excerpt":"","text":"《Achicving accuracy and scalability simultaneously in detetcing application clone on Android markets》来源：ICSE 2014关键词：Software analysis, Android, clone detection, centroid摘要： 本文针对安卓市场上的重打包问题，提出了基于opcode相似性的检测方案。参考物理学中的“质心”（centroid）概念，此文定义了一个图的几何特征， 构建了基于权重的3D-CFG图，用于测量两个APP的methods的相似度，根据相似度得出是否为APP克隆的结论，有较高的精确度(accuracy)及较大的应用规模(scalability)。参考官方讲解 1. 背景简介App Clones的特征：（1）A billion opcode problem：opcode量大（2) code fragment clones and app clones： code fragment相似不代表是克隆APP，可能是相同三方库。只有核心代码相同才算克隆 (3) Type 2 and Type 3 clones are prevalent on Android markets： 目前市场的APP clone大多是2,3类型的。 四种克隆类型： （1）大部分代码完全相同 （2）大部分代码语义完全相同 （3）代码有改动，增添或删减部分代码 （4）相同的算法，但应用的形式有变化 2. 现状分析 很多方法只能区分1类型，对于2,3类型的分析准确度不足,例如String-based, token-basedand AST (Abstract Syntax Tree)-based等等PDG（program dependence graph）等依靠图的同态来分析的方法，对于2,3类型的准确度足够，但存在效率不足的问题。table 1是对之前的检测方法的对比，之前的方法都是对code fragment的相似性进行检测，并不能保证代码是克隆的。 结论：（1）依靠图来分析方法，如果能够避免利用图的同态性（graph isomorphism）来分析，会大大提高效率（2）分辨app clone需要比较不同市场中的APP，代码量巨大。一对一比较的复杂度为C（2，M），M为method个数。需要降低这个复杂度 特点： （1）在保证针对2,3类型的准确率的同时，不用同态性比较，大大提高了效率。 （2）在比较之前进行分类，不需要一对一的比较，复杂度降低，提升效率。 （3）只比较core functionalities，可以有效针对添加库和广告的克隆 3. 文章方法centroidPDG（program dependence graph） -&gt; CFG(control flow graph) -&gt; 3D-CFG -&gt; centroid(重心坐标)centroid相同，method一定相同，同时具有单调性，centroid相差大，method相差一定大。 *定义了Application Similarity Degree(ASD) *定义了可能是克隆的分组规则Clone Group，将centroid相近的分在一起，用于比较。 主要思想：*3D-CFG：CFG的每一个节点都有唯一的一个坐标(x,y,z)。x代表CFG中的序列号，y代表出度，z代表参与的loop个数。序列号x的选择：从1开始，按照更多statement-&gt;更大binary值 来给分支中的节点标号，最后的return语句代表stop节点。 *centroid的定义：其中wp代表在基本块p中的statement数量 *method级别的相似性度量Centroid Difference Degree(CDD)：若两个method相同，则CDD=0 *通过去除同一作者的app，和公开的framework和第三方库，来集中寻找cloned apps。 流程： （1）在不同市场下载APP，转化为smali （2）转化为centroid，存入数据库，包含market name,app file name, class name, method name and centroid （3）将每个method只与Clone Group中的method相比较，复杂度为 M*c, c &lt;&lt; M 4.实验评估第三方Android应用市场（apk数据来源）：2 American markets (Pandaapp and Slideme) 2 Chinese markets (Anzhi and Dangle) 1 European market (Opera). 结果：误报率：&lt;1%漏报率：0.4—0.7%同时具有较高的效率，一个小时可以处理150145个APP,每个method只需同组内小于8个其他的method进行比较。如果有新的APP与数据库中已有数据比较，效率也是很快。。 limitations (1)不能检测到Type 4的app clone，但实际上没有在应用市场中找到第四种类型的app (2)在较小的CFG中添加一个节点会很大的改变centroid，但实际上小CFG只占2.3%。 (3)app clone通过值克隆一小部分method而逃逸检测 (4)若app clone的opcode比原始app多，则可能不会检测到。","categories":[{"name":"Paper","slug":"Paper","permalink":"https://skylinelulu.github.io/categories/Paper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"methods similarity calculation","slug":"methods-similarity-calculation","permalink":"https://skylinelulu.github.io/tags/methods-similarity-calculation/"}]},{"title":"hexo发博之路","slug":"hexo-pic","date":"2018-06-24T08:27:23.000Z","updated":"2018-07-01T08:13:53.487Z","comments":true,"path":"2018/06/24/hexo-pic/","link":"","permalink":"https://skylinelulu.github.io/2018/06/24/hexo-pic/","excerpt":"","text":"小白在发博客时遇到了好多问题，就在这里记录一下吧~ 1.如何在博客中插入图片？参考文章 （1）把主页配置文件_config.yml 里的post_asset_folder选项设置为true（2）在hexo目录下执行命令：npm install hexo-asset-image –save，即下载安装可以上传本地图片的插件hexo-asset-image（3）再运行hexo n “xxx”来生成md博文时，/source/_posts文件夹内除了xxx.md文件还有一个同名的文件夹（4）最后在xxx.md中想引入图片时，先把图片复制到xxx这个文件夹中，然后只需要在xxx.md中按照markdown的格式引入图片：(5)检查一下，hexo g生成页面后，进入public\\2018\\06\\24\\index.html文件中查看相关字段，可以发现，html标签内的语句是而不是 (6)最后, hexo d上传，OK！","categories":[{"name":"tool","slug":"tool","permalink":"https://skylinelulu.github.io/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://skylinelulu.github.io/tags/hexo/"}]},{"title":"Z3求解器在Windows下的安装","slug":"Z3SMT","date":"2018-06-24T08:13:24.000Z","updated":"2018-06-24T08:15:18.907Z","comments":true,"path":"2018/06/24/Z3SMT/","link":"","permalink":"https://skylinelulu.github.io/2018/06/24/Z3SMT/","excerpt":"","text":"z3（github链接点这里）是由微软公司开发的一个SMT求解器（定理证明器），能够检查逻辑表达式的可满足性。 环境： Visual Studio 2015 Command Prompt 安装准备： 配置Visual Studio Command Prompt：在Visual Studio的菜单栏中选择 工具-外部工具-添加参数为标题：mycmd命令：C:\\Windows\\System32\\cmd.exe参数：/k “D:\\VS2015\\Common7\\Tools\\VsDevCmd.bat”初始目录：$(ProjectDir) 打开Visual Studio Command Prompt:电脑的开始-Visual Studio 2015-目录下有各种环境下的命令窗口，这里选择64位的。安装过程： 打开github上下载的Z3目录：cd F:\\z3-master\\z3-master 若Visual Studio为32-bit builds：1python scripts/mk_make.py 如果是64-bit build:1python scripts/mk_make.py -x cd build nmake若提示“Z3 was successfully built.”就成功了 5.然后按照提示，新建 PYTHONPATH环境变量，将build/python目录添加到其中；并将build添加到path环境变量中。","categories":[{"name":"tool","slug":"tool","permalink":"https://skylinelulu.github.io/categories/tool/"}],"tags":[{"name":"Z3","slug":"Z3","permalink":"https://skylinelulu.github.io/tags/Z3/"}]},{"title":"64位Windows中IAT表的获取","slug":"64位Windows中IAT表的获取","date":"2018-06-09T07:23:47.000Z","updated":"2018-07-01T08:14:37.638Z","comments":true,"path":"2018/06/09/64位Windows中IAT表的获取/","link":"","permalink":"https://skylinelulu.github.io/2018/06/09/64位Windows中IAT表的获取/","excerpt":"","text":"这个之后详细再写出来","categories":[{"name":"Windows","slug":"Windows","permalink":"https://skylinelulu.github.io/categories/Windows/"}],"tags":[{"name":"Windows IAT","slug":"Windows-IAT","permalink":"https://skylinelulu.github.io/tags/Windows-IAT/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"}]},{"title":"ADBI框架在Android6.0平台上的使用","slug":"ADBI框架在Android6.0平台上的使用","date":"2018-06-03T07:34:54.000Z","updated":"2018-06-03T07:34:07.466Z","comments":true,"path":"2018/06/03/ADBI框架在Android6.0平台上的使用/","link":"","permalink":"https://skylinelulu.github.io/2018/06/03/ADBI框架在Android6.0平台上的使用/","excerpt":"","text":"环境： Android 6.0 问题： ADBI框架在Android5上可以稳定运行，但是在Android6.0中并不能得到函数在GOT表中保存的真正地址。Inline hook方式也会出现此问题，导致hook失败。 原因： 经过对hook框架的研读，参考了网上对Android5-6的变化，我发现Android6.0里面的GOT HOOK框架有改变，Android6的动态库加载的基地址不再固定，即和/proc/id/maps里的地址不一致了。因此之前通过/proc/id/maps拿到的基地址不正确。 解决思路： 通过soinfo结构拿到load_bias来作为基地址去算got函数地址的偏移。就是将module_base改成load_bias。 具体代码： 分成两部分：一个是GOT hook，一个是inline hook. 1.GOT hook(hook.c)在Android5.0中，get_module_base的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * lookup the start address of a specific module * return 0 if FAILED */ //函数功能：在指定pid的内存文件中查找包含module_path字符串的so，并返回其在内存中的起始地址//成功返回so起始地址，失败返回0uint32_t get_module_base(pid_t pid, const char *module_path)&#123; FILE *fp = NULL; char *pch = NULL; char filename[32]; char line[512]; uint32_t addr = 0; //若pid为负值，proc/self/maps是查找本进程的内存映射信息 //snprintf()对filename字串赋值 if ( pid &lt; 0 ) snprintf(filename, sizeof(filename), \"/proc/self/maps\"); //若pid为非负值，proc/pid/maps查找指定pid进程的内存映射信息 else snprintf(filename, sizeof(filename), \"/proc/%d/maps\", pid); //处理打开内存文件失败 if ( (fp = fopen(filename, \"r\")) == NULL ) &#123; LOGE(\"open %s failed!\", filename); return 0; &#125; //逐行读取内存文件maps while ( fgets(line, sizeof(line), fp) ) &#123; //如果在maps文件中搜索在module_path字符串（模块名称？） if ( strstr(line, module_path) ) &#123; LOGE(\"[+]:2\"); //strtok()把字串line按\"-\"分割，返回被分割出字符串的指针 pch = strtok(line, \"-\"); //strtoul()把字串pch转换成16进制 //此处addr为模块所处内存空间的起始地址（XXX-YYY中的XXX） addr = strtoul(pch, NULL, 16); break; &#125; &#125; fclose(fp); return addr;&#125; 在Android6.0中，在hook.c文件中添加soinfo的结构体定义:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 typedef struct link_map_t &#123; uintptr_t l_addr; char* l_name; uintptr_t l_ld; struct link_map_t* l_next; struct link_map_t* l_prev;&#125; link_map_t;typedef void (*linker_function_t)();#define SOINFO_NAME_LEN 128typedef struct soinfo &#123; char name[SOINFO_NAME_LEN]; const Elf32_Phdr* phdr; size_t phnum; Elf32_Addr entry; Elf32_Addr base; unsigned size; uint32_t unused1; // DO NOT USE, maintained for compatibility. Elf32_Dyn* dynamic; uint32_t unused2; // DO NOT USE, maintained for compatibility uint32_t unused3; // DO NOT USE, maintained for compatibility struct soinfo* next; unsigned flags; const char* strtab; Elf32_Sym* symtab; size_t nbucket; size_t nchain; unsigned* bucket; unsigned* chain; //------------------ // This is only used by 32-bit MIPS, but needs to be here for // all 32-bit architectures to preserve binary compatibility. unsigned* plt_got; Elf32_Rel* plt_rel; size_t plt_rel_count; Elf32_Rel* rel; size_t rel_count; linker_function_t* preinit_array; size_t preinit_array_count; linker_function_t* init_array; size_t init_array_count; linker_function_t* fini_array; size_t fini_array_count; linker_function_t init_func; linker_function_t fini_func; // ARM EABI section used for stack unwinding. unsigned* ARM_exidx; size_t ARM_exidx_count; size_t ref_count; link_map_t link_map; int constructors_called; // When you read a virtual address from the ELF file, add this // value to get the corresponding address in the process' address space. Elf32_Addr load_bias;&#125; soinfo;uint32_t load_bias_addr; 并修改get_module_base的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748uint32_t get_module_base(pid_t pid, const char *module_path)&#123; FILE *fp = NULL; char *pch = NULL; char filename[32]; char line[512]; uint32_t addr = 0; void *handle = dlopen( LIBSF_PATH, RTLD_GLOBAL); soinfo *si = (soinfo*)handle; addr = si-&gt;base; load_bias_addr = si-&gt;load_bias; //若pid为负值，proc/self/maps是查找本进程的内存映射信息 //snprintf()对filename字串赋值 if ( pid &lt; 0 ) snprintf(filename, sizeof(filename), \"/proc/self/maps\"); //若pid为非负值，proc/pid/maps查找指定pid进程的内存映射信息 else snprintf(filename, sizeof(filename), \"/proc/%d/maps\", pid); //处理打开内存文件失败 if ( (fp = fopen(filename, \"r\")) == NULL ) &#123; LOGE(\"open %s failed!\", filename); return 0; &#125; //逐行读取内存文件maps while ( fgets(line, sizeof(line), fp) ) &#123; //如果在maps文件中搜索在module_path字符串（模块名称？） if ( strstr(line, module_path) ) &#123; LOGE(\"[+]:2\"); //strtok()把字串line按\"-\"分割，返回被分割出字符串的指针 pch = strtok(line, \"-\"); //strtoul()把字串pch转换成16进制 //此处addr为模块所处内存空间的起始地址（XXX-YYY中的XXX） addr = strtoul(pch, NULL, 16); break; &#125; &#125; fclose(fp); return addr;&#125; 2.Inline hook(inlineHook.c)在Android5.0中，其中find_name(参考文章点这里)的代码如下：12345678910111213141516171819202122232425262728293031323334353637int find_name(pid_t pid, char *name, char *libn, unsigned long *addr)&#123; struct mm mm[1000]; unsigned long libcaddr; int nmm; char libc[1024]; symtab_t s; if (0 &gt; load_memmap(pid, mm, &amp;nmm)) &#123; log(\"[-] cannot read memory map\\n\") return -1; &#125; else log(\"[+] success load memory map\") if (0 &gt; find_libname(libn, libc, sizeof(libc), &amp;libcaddr, mm, nmm)) &#123; log(\"[-] cannot find lib: %s\\n\", libn) return -1; &#125; else log(\"[+] success find lib name: 0x%X\", libcaddr) log(\"[+] lib: &gt;%s&lt;\\n\", libc) s = load_symtab(libc); if (!s) &#123; log(\"[-] cannot read symbol table\\n\") return -1; &#125;else log(\"[+] success read symbol table\") if (0 &gt; lookup_func_sym(s, name, addr)) &#123; log(\"[-] cannot find function: %s\\n\", name) return -1; &#125;else log(\"[+] success find function: %s: addr - 0x%X, *addr - 0x%X\", name, addr, *addr) *addr += libcaddr; return 0;&#125; 在Android6.0中，在inlineHook.c文件中同样添加上述soinfo的结构体定义，并修改find_name函数为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int find_name(pid_t pid, char *name, char *libn, unsigned long *addr, int syslib)&#123; struct mm mm[1000]; unsigned long libcaddr; int nmm; char libc[1024]; symtab_t s; if (0 &gt; load_memmap(pid, mm, &amp;nmm)) &#123; log(\"[-] cannot read memory map\\n\") return -1; &#125; else log(\"[+] success load memory map\") if (0 &gt; find_libname(libn, libc, sizeof(libc), &amp;libcaddr, mm, nmm)) &#123; log(\"[-] cannot find lib: %s\\n\", libn) return -1; &#125; else log(\"[+] success find lib name: 0x%X\", libcaddr) log(\"[+] lib: &gt;%s&lt;\\n\", libc) s = load_symtab(libc); if (!s) &#123; log(\"[-] cannot read symbol table\\n\") return -1; &#125;else log(\"[+] success read symbol table\") if (0 &gt; lookup_func_sym(s, name, addr)) &#123; log(\"[-] cannot find function: %s\\n\", name) return -1; &#125;else log(\"[+] success find function: %s: addr - 0x%X, *addr - 0x%X\", name, addr, *addr) log(\"[+] libcaddr is 0x%X\\n\", libcaddr) void *handle = dlopen( LIBSF_PATH, RTLD_GLOBAL); soinfo *si = (soinfo*)handle; load_bias_addr = si-&gt;load_bias; log(\"[+] load_bias_addr is 0x%X\\n\", load_bias_addr) if(syslib == 0)&#123; *addr += libcaddr; &#125;else if(syslib == 1)&#123; *addr += load_bias_addr; &#125;else&#123; log(\"[-] parameter syslib is wrong !\\n\") &#125; return 0;&#125; 源码之后整理一下会放出来，有什么问题可以直接来问我~","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"},{"name":"ADBI","slug":"ADBI","permalink":"https://skylinelulu.github.io/tags/ADBI/"}]},{"title":"xposed中函数参数byte[]类型数据读取","slug":"xposed-byte[]","date":"2018-06-03T03:07:02.000Z","updated":"2018-06-03T07:02:04.863Z","comments":true,"path":"2018/06/03/xposed-byte[]/","link":"","permalink":"https://skylinelulu.github.io/2018/06/03/xposed-byte[]/","excerpt":"","text":"之前hook native函数是使用ADBI框架的，但是其平台有限，Android5效果稳定，Android6成功率不高，到Android7就无法使用了。由于xposed（已支持Android8）也可以Hook native函数，可获取native函数的参数数据，因此想将hook的函数从ADBI框架移植到xposed模块中。但是遇到了一个问题：之前使用ADBI框架获取byte[]类型的参数数据是正常的，但是在xposed中只能获取到地址，一直提示参数为object类型。那么如何在xposed中获得真实数据呢？解决方案参考如下。 如下为ADBI框架中重写的函数，获取byte类型参数a的数据，并写入/sdcard/data.txt中。 123456789101112131415161718192021222324void new_hookData(JNIEnv* env, jobject thiz, jbyte *a) &#123; jbyte *arrayBody = (*env)-&gt;GetByteArrayElements(env,a,NULL); jsize len = (*env)-&gt;GetArrayLength(env,a); byte *dDate = (byte *)arrayBody; int fd = open(\"/sdcard/data.txt\", O_APPEND|O_RDWR|O_CREAT,S_IRWXU); if(fd &lt; 0) &#123; LOGI(\"[+] open failed\"); LOGW(\"[+] error (errno=%d)\", errno); &#125; else &#123; LOGI(\"[+] success open\"); &#125; int write_len = write(fd, dDate, len); (*env)-&gt;ReleaseByteArrayElements(env,a,arrayBody,NULL); close(fd); old_hookData(env, thiz, a);&#125; 如下是xposed中的hook代码： 1234567891011121314151617181920212223findAndHookMethod(\"className\",lp.classLoader,\"methodName\",byte[].class, new hookData());class hookData extends XC_MethodHook&#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; byte[] buf = (byte[])param.args[0]; FileHelper filehelper = new FileHelper(); try &#123; //将byte数组写入文件 createFile(\"/sdcard/data.txt\", buf); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //将byte数组写入文件 public void createFile(String path, byte[] content) throws IOException &#123; FileOutputStream fos = new FileOutputStream(path); fos.write(content); fos.close(); &#125;&#125; over!","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"},{"name":"xposed","slug":"xposed","permalink":"https://skylinelulu.github.io/tags/xposed/"}]},{"title":"Android Permission Unleashed","slug":"Android Permissions Unleashed","date":"2018-05-31T10:02:17.000Z","updated":"2018-06-03T07:54:21.216Z","comments":true,"path":"2018/05/31/Android Permissions Unleashed/","link":"","permalink":"https://skylinelulu.github.io/2018/05/31/Android Permissions Unleashed/","excerpt":"","text":"《Android permissions unleashed》来源：CSF 2015关键词：定理证明器，Android权限模型，策略摘要： 本文利用定力证明器为Android权限建模，将组件的权限定制成策略集合，提出了两个概念：一个是组件栈（Component stack），由frame组成,而frame F = { C, P, Φ }，其中， C为component，P为权限集，Φ为策略集。第二个是系统配置，由组件栈组成，Σ = [S1; S2; . . .]；针对frame，stack和configuration制了相应的策略范围direct,local和global；将example中的权限与上述结合，构建了权限、组件和策略的逻辑表达。","categories":[{"name":"Paper","slug":"Paper","permalink":"https://skylinelulu.github.io/categories/Paper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"permission","slug":"permission","permalink":"https://skylinelulu.github.io/tags/permission/"}]},{"title":"三星s7 edge(G9350)刷机经验","slug":"SUMSUNG-ROOT","date":"2018-05-12T13:09:32.000Z","updated":"2018-06-03T07:11:27.348Z","comments":true,"path":"2018/05/12/SUMSUNG-ROOT/","link":"","permalink":"https://skylinelulu.github.io/2018/05/12/SUMSUNG-ROOT/","excerpt":"","text":"设备：Sumsung S7 Edge刷入系统: Android 7刷机方式：线刷需要安装包： 链接：https://pan.baidu.com/s/1N8U0KFikiGz_QFnfC9EUQg 密码：vuy0 步骤：1.刷系统。电脑端打开odin刷机软件。手机关机情况下，同时按住“音量键下”+“HOME键”+“开机键”进入开机模式，按照提示按下音量上键。按照顺序刷入五件套，即S7android7.0文件夹中的文件。具体教程2.解锁。进入系统，运行“三星解锁.apk”，进行解锁。3.ROOT（参考：7.0ROOT步骤.txt）。再次关机，同时按住“音量键下”+“HOME键”+“开机键”进入开机模式，打开odin，AP刷入recovery，即G9350_7.0_QC1_twrp_kernel_su2.79.tar文件。在odin的options中去掉Auto Reboot的对勾。start。手机进入twrp模式，清除，格式化data分区，输入yes，重启手机。备注：查看设置-关于手机-软件信息-版本号，我的手机的版本号后三位为QC1，因此采用该recovery文件。 开机，adb shell, su，就可以看到设备已经ROOT，data也解密了。","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"Sumsung Root","slug":"Sumsung-Root","permalink":"https://skylinelulu.github.io/tags/Sumsung-Root/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-12T12:14:09.851Z","updated":"2018-06-24T08:26:42.734Z","comments":true,"path":"2018/05/12/hello-world/","link":"","permalink":"https://skylinelulu.github.io/2018/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}
{"meta":{"title":"SkylineLulu","subtitle":null,"description":"在头顶上，有几千亿的光年。","author":"SkylineLulu","url":"https://skylinelulu.github.io"},"pages":[{"title":"categories","date":"2018-05-12T13:22:49.000Z","updated":"2018-06-04T04:33:30.599Z","comments":false,"path":"categories/index.html","permalink":"https://skylinelulu.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-12T13:20:42.000Z","updated":"2018-06-04T04:35:15.206Z","comments":false,"path":"tags/index.html","permalink":"https://skylinelulu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QQ表情-脏话bug漏洞","slug":"QQEmojiBug","date":"2018-09-02T09:02:32.000Z","updated":"2018-09-03T14:13:11.503Z","comments":true,"path":"2018/09/02/QQEmojiBug/","link":"","permalink":"https://skylinelulu.github.io/2018/09/02/QQEmojiBug/","excerpt":"","text":"最近洗心革面，好像新学期伊始就能给人很大的力量，希望可以坚持~今天看到一篇分析QQ表情bug的博客，记录一下学习过程，原博戳这里 1. bugAndroid 7.6.0-7.6.3版本的QQ发送[菜刀]+数字+[表情]就会转换成脏话发出去. 2. 分析（1）下载三个版本中任意一个版本，这里下载的是7.6.0。测试一下，[菜刀]+”1”+[心] 被转换为死胖子， [菜刀]+” “+[心] 被转换为 [跳舞]AmN you（2）通过字符串搜索定位到com.tencent.mobilqq.lovelanguage.LoveLanguageConfig.class（3）f9982a脏话的引用处：a. public static String a(String str)，将前6个char改变大小写，这也是为什么”damn you”被转为了”[跳舞]AmN you” 的一个原因。这个暂时没理清。b. public static boolean m1991a(char c) ，看是否下标越界c. public static String a(String str)中if (str4.equals(substring.toLowerCase())) 判断是否收到骂人的话，是的话就换成友好的表情d. public int a(EditText editText) 似乎是判断是否发出骂人的话，是的话就换成友好的表情e. public void m1994a(EditText editText) 判断是否输入0x11,a,b,c，是的话就替换为脏话（4）LoveLanguageConfig中有两个对 char 的运算分析一下， [菜刀]+”1”+[心] 被转换为死胖子， [菜刀]+” “+[心] 被转换为 [跳舞]AmN you 。而 “1”的ASCII码为49，” “的ASCII码是32，两者的差是 17，在数组中，死胖子和 damn you 的间隔也是 17。而 “ “与(char)30的差是2，2在数组中是”damn you”。所以这个运算就是将char和数组对应起来。（5）LoveLanguageManager中的public int a(EditText editText)判断发出的话是否是脏话。如果输入框内容发现有 ‘\\x11’ + charA + charB + charC 这种格式的，调用 LoveLanguageConfig.a函数，进行转化后替换掉原来的文本，之后发出去。绝大部分情况下，用户肯定不会输入 \\x11 这个字符，所以猜测是[菜刀]表情编码中带有 \\x11，然后拼接了后面的几个任意的 char，就会被替换成脏话。【后来发现菜刀确实是 \\x14\\x11组成的】（6）LoveLanguageManager中的public void a(EditText editText)判断收到的话是否是脏话。验证一下猜想，输入 [菜刀]+”111” ，触发；输入 [菜刀]+1234567 ，发现123消失了。（7）这里顺便贴一下原作者的xposed实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859ClassLoader loader = loadPackageParam.classLoader;Log.d(TAG, \"start hook\");XposedHelpers.findAndHookMethod(\"com.tencent.qphone.base.util.QLog\", loader, \"d\", String.class, int.class, String.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Log.d(TAG, param.args[0] + \"\\t\" + param.args[2]); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); &#125;&#125;);XposedHelpers.findAndHookMethod(\"com.tencent.qphone.base.util.QLog\", loader, \"isColorLevel\", new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable &#123; return true; &#125;&#125;);XposedHelpers.findAndHookMethod(\"com.tencent.mobileqq.lovelanguage.LoveLanguageManager\", loader, \"a\", EditText.class, new XC_MethodReplacement() &#123; @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable &#123; return 0; &#125;&#125;);XposedHelpers.findAndHookMethod(\"com.tencent.mobileqq.lovelanguage.LoveLanguageManager\", loader, \"a\", EditText.class, new XC_MethodHook() &#123; @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; super.beforeHookedMethod(param); Object obj = param.thisObject; Method[] methods = obj.getClass().getDeclaredMethods(); for (Method m : methods) &#123; Log.e(TAG, m.toGenericString() + \"===\" + printHexString(m.getName())); &#125; EditText editText = (EditText) param.args[0]; String s = editText.getText().toString(); Log.d(TAG, \"input=\" + s); Log.d(TAG, \"input=\" + printHexString(s)); &#125; @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123; super.afterHookedMethod(param); EditText editText = (EditText) param.args[0]; String s = editText.getText().toString(); Log.d(TAG, \"after=\" + s); Log.d(TAG, \"after=\" + printHexString(s)); &#125;&#125;);Log.d(TAG, \"end hook\"); 我们输入：[菜刀]1[心]的时候输入输出的Log:1234505-28 04:24:03.716 1511-1511/com.tencent.mobileqq D/LDB: input=1J05-28 04:24:03.716 1511-1511/com.tencent.mobileqq D/LDB: input=141131144a05-28 04:24:03.866 1511-1511/com.tencent.mobileqq D/LDB: LoveLanguageManager love language report 0X800916705-28 04:24:03.866 1511-1511/com.tencent.mobileqq D/LDB: after=死胖子05-28 04:24:03.866 1511-1511/com.tencent.mobileqq D/LDB: after=14e6adbbe88396e5ad90 我们输入：[菜刀]123的时候123405-28 05:04:28.338 1511-1511/com.tencent.mobileqq D/LDB: input=12305-28 05:04:28.338 1511-1511/com.tencent.mobileqq D/LDB: input=141131323305-28 05:04:28.347 1511-1511/com.tencent.mobileqq D/LDB: after=死胖子05-28 05:04:28.347 1511-1511/com.tencent.mobileqq D/LDB: after=14e6adbbe88396e5ad90 我们输入：[菜刀]空格[心]的时候123405-28 05:11:06.107 1511-1511/com.tencent.mobileqq D/LDB: input= J05-28 05:11:06.107 1511-1511/com.tencent.mobileqq D/LDB: input=141120144a05-28 05:11:06.120 1511-1511/com.tencent.mobileqq D/LDB: after=dAmN you05-28 05:11:06.120 1511-1511/com.tencent.mobileqq D/LDB: after=1464416d4e20796f75 （8）[菜刀]表情包含2个 char，是 \\x14\\x11 ，既然如此，这里又有一个细节，其实转化为脏话以后，第一个 char 还是保留着的，当它与字母拼接时，是可以组合成 QQ 快捷表情发出去的，比如[菜刀]+”9”+“gh”发出去就是[加油拳头]dIot。","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"reverse","slug":"reverse","permalink":"https://skylinelulu.github.io/tags/reverse/"}]},{"title":"Intersection Automata based model for Android Application Collusion","slug":"Intersection Automata","date":"2018-08-23T02:23:07.000Z","updated":"2018-09-09T13:12:04.863Z","comments":true,"path":"2018/08/23/Intersection Automata/","link":"","permalink":"https://skylinelulu.github.io/2018/08/23/Intersection Automata/","excerpt":"","text":"《Intersection Automata based model for Android Application Collusion》来源：AINA 2016 (CCF B)关键词：automata, Android, ICC Collusion Attack摘要： 本文针对安卓中存在的基于intent的ICC Collusion Attack，使用有限状态自动机方法从组件层面进行检测。 1.针对问题：Android 多个应用之间的互相调用和交互时存在ICC Collusion Attack ICC Collusion Attack：两个应用之间的组件调用，但是两个应用所拥有的权限不同，因此应用A可以通过应用B可以获取不属于应用A的权限，导致权限提升问题。可以称之为组件间通信合谋攻击。 Treat Model：如下图(msgRead与msgSend应用之间存在提权攻击)所示，msgRead拥有接收短信和读取短信的权限，msgSend拥有写短信和发短信的权限，msgRead通过Intent与msgSend交互时，可能存在将短信内容通过intent发送给msgSend，导致隐私泄露。 2.contribution（1） 第一个使用非确定性有限状态自动机来标识基于ICC的Intent,使用app之间的通讯和相关策略的制定来检测攻击（2） 在组件层面分析（传统工作都基于应用或方法层面分析，不精确且应用范围小）（3） 对21个app组合成的210对进行测试，成功检测（4） 时间和内存都是线性的 3.Challenge（1） App之间的ICC Collusion Attack检测比较难（2） ICC Collusion Attack与隐式intent相关联，如何将intent与隐私泄露结合，实际上需要考虑intent-component-permission这条链。（3） 将app行为与定制的策略相结合 4.文章方法由于intent的发送者和接收者组件权限不相等，因此ICC Collusion Attack检测问题可以被视为字符串搜索和模式匹配问题。所以本文提出了组件层面的自动机检测方案。该交叉自动机由两个自动机组成。提取两个app(A和B)中的调用图，如果A的组件发送一个Intent给应用B符合intent-filter的组件，则A和B之间使用边连接起来（application自动机）。检测这些边是否破坏了我们定义的安全权限策略（policy自动机）。(1)application自动机第一个是对app进行分析得到的Application自动机，描述函数和权限之间的关系，如图2(application自动机示意图)所示。（1）首先提取app中的图，顶点代表所有的组件，定义intent的源组件和目标组件，边即连接源组件和目标组件。（2）将两个app的顶点和边形成的图进行联合。（3）减少与权限无关的边（4）将图转换成自动机，该自动机大小为n（n是app中组件数量）。 (2)policy自动机第二个自动机描述权限和隐私泄露之间的关系，Collusion attack发生是因为危险权限以一定的顺序被使用，policy自动机如图3所示。最终的自动机结合了权限，函数调用和隐私泄露的policy，最终检测出ICC Collusion Attack，如图4(交叉自动机示意图)所示。 5.evaluation数据来源：21个app（14app(自己设计)+ 3 app(DroidBench)+ 4app(Google Play)）两两app进行组合，总210对app组结果：21个app之间存在发送短信，泄露位置等隐私泄露现象。实验证明自动机状态数与分析的app组件数是线性关系。","categories":[{"name":"Paper","slug":"Paper","permalink":"https://skylinelulu.github.io/categories/Paper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"automata","slug":"automata","permalink":"https://skylinelulu.github.io/tags/automata/"}]},{"title":"Similarity of Android App Methods","slug":"3D-CFG","date":"2018-07-01T07:14:43.000Z","updated":"2018-09-03T13:45:45.862Z","comments":true,"path":"2018/07/01/3D-CFG/","link":"","permalink":"https://skylinelulu.github.io/2018/07/01/3D-CFG/","excerpt":"","text":"《Achicving accuracy and scalability simultaneously in detetcing application clone on Android markets》来源：ICSE 2014关键词：Software analysis, Android, clone detection, centroid摘要： 本文针对安卓市场上的重打包问题，提出了基于opcode相似性的检测方案。参考物理学中的“质心”（centroid）概念，此文定义了一个图的几何特征， 构建了基于权重的3D-CFG图，用于测量两个APP的methods的相似度，根据相似度得出是否为APP克隆的结论，有较高的精确度(accuracy)及较大的应用规模(scalability)。参考官方讲解 1. 背景简介App Clones的特征：（1）A billion opcode problem：opcode量大（2) code fragment clones and app clones： code fragment相似不代表是克隆APP，可能是相同三方库。只有核心代码相同才算克隆 (3) Type 2 and Type 3 clones are prevalent on Android markets： 目前市场的APP clone大多是2,3类型的。 四种克隆类型： （1）大部分代码完全相同 （2）大部分代码语义完全相同 （3）代码有改动，增添或删减部分代码 （4）相同的算法，但应用的形式有变化 2. 现状分析 很多方法只能区分1类型，对于2,3类型的分析准确度不足,例如String-based, token-basedand AST (Abstract Syntax Tree)-based等等PDG（program dependence graph）等依靠图的同态来分析的方法，对于2,3类型的准确度足够，但存在效率不足的问题。table 1是对之前的检测方法的对比，之前的方法都是对code fragment的相似性进行检测，并不能保证代码是克隆的。 结论：（1）依靠图来分析方法，如果能够避免利用图的同态性（graph isomorphism）来分析，会大大提高效率（2）分辨app clone需要比较不同市场中的APP，代码量巨大。一对一比较的复杂度为C（2，M），M为method个数。需要降低这个复杂度 特点： （1）在保证针对2,3类型的准确率的同时，不用同态性比较，大大提高了效率。 （2）在比较之前进行分类，不需要一对一的比较，复杂度降低，提升效率。 （3）只比较core functionalities，可以有效针对添加库和广告的克隆 3. 文章方法centroidPDG（program dependence graph） -&gt; CFG(control flow graph) -&gt; 3D-CFG -&gt; centroid(重心坐标)centroid相同，method一定相同，同时具有单调性，centroid相差大，method相差一定大。 *定义了Application Similarity Degree(ASD) *定义了可能是克隆的分组规则Clone Group，将centroid相近的分在一起，用于比较。 主要思想：*3D-CFG：CFG的每一个节点都有唯一的一个坐标(x,y,z)。x代表CFG中的序列号，y代表出度，z代表参与的loop个数。序列号x的选择：从1开始，按照更多statement-&gt;更大binary值 来给分支中的节点标号，最后的return语句代表stop节点。 *centroid的定义：其中wp代表在基本块p中的statement数量 *method级别的相似性度量Centroid Difference Degree(CDD)：若两个method相同，则CDD=0 *通过去除同一作者的app，和公开的framework和第三方库，来集中寻找cloned apps。 流程： （1）在不同市场下载APP，转化为smali （2）转化为centroid，存入数据库，包含market name,app file name, class name, method name and centroid （3）将每个method只与Clone Group中的method相比较，复杂度为 M*c, c &lt;&lt; M 4.实验评估第三方Android应用市场（apk数据来源）：2 American markets (Pandaapp and Slideme) 2 Chinese markets (Anzhi and Dangle) 1 European market (Opera). 结果：误报率：&lt;1%漏报率：0.4—0.7%同时具有较高的效率，一个小时可以处理150145个APP,每个method只需同组内小于8个其他的method进行比较。如果有新的APP与数据库中已有数据比较，效率也是很快。。 limitations (1)不能检测到Type 4的app clone，但实际上没有在应用市场中找到第四种类型的app (2)在较小的CFG中添加一个节点会很大的改变centroid，但实际上小CFG只占2.3%。 (3)app clone通过值克隆一小部分method而逃逸检测 (4)若app clone的opcode比原始app多，则可能不会检测到。","categories":[{"name":"Paper","slug":"Paper","permalink":"https://skylinelulu.github.io/categories/Paper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"methods similarity calculation","slug":"methods-similarity-calculation","permalink":"https://skylinelulu.github.io/tags/methods-similarity-calculation/"}]},{"title":"hexo发博之路","slug":"hexo-pic","date":"2018-06-24T08:27:23.000Z","updated":"2018-07-01T08:13:53.487Z","comments":true,"path":"2018/06/24/hexo-pic/","link":"","permalink":"https://skylinelulu.github.io/2018/06/24/hexo-pic/","excerpt":"","text":"小白在发博客时遇到了好多问题，就在这里记录一下吧~ 1.如何在博客中插入图片？参考文章 （1）把主页配置文件_config.yml 里的post_asset_folder选项设置为true（2）在hexo目录下执行命令：npm install hexo-asset-image –save，即下载安装可以上传本地图片的插件hexo-asset-image（3）再运行hexo n “xxx”来生成md博文时，/source/_posts文件夹内除了xxx.md文件还有一个同名的文件夹（4）最后在xxx.md中想引入图片时，先把图片复制到xxx这个文件夹中，然后只需要在xxx.md中按照markdown的格式引入图片：(5)检查一下，hexo g生成页面后，进入public\\2018\\06\\24\\index.html文件中查看相关字段，可以发现，html标签内的语句是而不是 (6)最后, hexo d上传，OK！","categories":[{"name":"tool","slug":"tool","permalink":"https://skylinelulu.github.io/categories/tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://skylinelulu.github.io/tags/hexo/"}]},{"title":"Z3求解器在Windows下的安装","slug":"Z3SMT","date":"2018-06-24T08:13:24.000Z","updated":"2018-06-24T08:15:18.907Z","comments":true,"path":"2018/06/24/Z3SMT/","link":"","permalink":"https://skylinelulu.github.io/2018/06/24/Z3SMT/","excerpt":"","text":"z3（github链接点这里）是由微软公司开发的一个SMT求解器（定理证明器），能够检查逻辑表达式的可满足性。 环境： Visual Studio 2015 Command Prompt 安装准备： 配置Visual Studio Command Prompt：在Visual Studio的菜单栏中选择 工具-外部工具-添加参数为标题：mycmd命令：C:\\Windows\\System32\\cmd.exe参数：/k “D:\\VS2015\\Common7\\Tools\\VsDevCmd.bat”初始目录：$(ProjectDir) 打开Visual Studio Command Prompt:电脑的开始-Visual Studio 2015-目录下有各种环境下的命令窗口，这里选择64位的。安装过程： 打开github上下载的Z3目录：cd F:\\z3-master\\z3-master 若Visual Studio为32-bit builds：1python scripts/mk_make.py 如果是64-bit build:1python scripts/mk_make.py -x cd build nmake若提示“Z3 was successfully built.”就成功了 5.然后按照提示，新建 PYTHONPATH环境变量，将build/python目录添加到其中；并将build添加到path环境变量中。","categories":[{"name":"tool","slug":"tool","permalink":"https://skylinelulu.github.io/categories/tool/"}],"tags":[{"name":"Z3","slug":"Z3","permalink":"https://skylinelulu.github.io/tags/Z3/"}]},{"title":"64位Windows中IAT表的获取","slug":"64位Windows中IAT表的获取","date":"2018-06-09T07:23:47.000Z","updated":"2018-07-01T08:14:37.638Z","comments":true,"path":"2018/06/09/64位Windows中IAT表的获取/","link":"","permalink":"https://skylinelulu.github.io/2018/06/09/64位Windows中IAT表的获取/","excerpt":"","text":"这个之后详细再写出来","categories":[{"name":"Windows","slug":"Windows","permalink":"https://skylinelulu.github.io/categories/Windows/"}],"tags":[{"name":"Windows IAT","slug":"Windows-IAT","permalink":"https://skylinelulu.github.io/tags/Windows-IAT/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"}]},{"title":"ADBI框架在Android6.0平台上的使用","slug":"ADBI框架在Android6.0平台上的使用","date":"2018-06-03T07:34:54.000Z","updated":"2018-06-03T07:34:07.466Z","comments":true,"path":"2018/06/03/ADBI框架在Android6.0平台上的使用/","link":"","permalink":"https://skylinelulu.github.io/2018/06/03/ADBI框架在Android6.0平台上的使用/","excerpt":"","text":"环境： Android 6.0 问题： ADBI框架在Android5上可以稳定运行，但是在Android6.0中并不能得到函数在GOT表中保存的真正地址。Inline hook方式也会出现此问题，导致hook失败。 原因： 经过对hook框架的研读，参考了网上对Android5-6的变化，我发现Android6.0里面的GOT HOOK框架有改变，Android6的动态库加载的基地址不再固定，即和/proc/id/maps里的地址不一致了。因此之前通过/proc/id/maps拿到的基地址不正确。 解决思路： 通过soinfo结构拿到load_bias来作为基地址去算got函数地址的偏移。就是将module_base改成load_bias。 具体代码： 分成两部分：一个是GOT hook，一个是inline hook. 1.GOT hook(hook.c)在Android5.0中，get_module_base的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * lookup the start address of a specific module * return 0 if FAILED */ //函数功能：在指定pid的内存文件中查找包含module_path字符串的so，并返回其在内存中的起始地址//成功返回so起始地址，失败返回0uint32_t get_module_base(pid_t pid, const char *module_path)&#123; FILE *fp = NULL; char *pch = NULL; char filename[32]; char line[512]; uint32_t addr = 0; //若pid为负值，proc/self/maps是查找本进程的内存映射信息 //snprintf()对filename字串赋值 if ( pid &lt; 0 ) snprintf(filename, sizeof(filename), \"/proc/self/maps\"); //若pid为非负值，proc/pid/maps查找指定pid进程的内存映射信息 else snprintf(filename, sizeof(filename), \"/proc/%d/maps\", pid); //处理打开内存文件失败 if ( (fp = fopen(filename, \"r\")) == NULL ) &#123; LOGE(\"open %s failed!\", filename); return 0; &#125; //逐行读取内存文件maps while ( fgets(line, sizeof(line), fp) ) &#123; //如果在maps文件中搜索在module_path字符串（模块名称？） if ( strstr(line, module_path) ) &#123; LOGE(\"[+]:2\"); //strtok()把字串line按\"-\"分割，返回被分割出字符串的指针 pch = strtok(line, \"-\"); //strtoul()把字串pch转换成16进制 //此处addr为模块所处内存空间的起始地址（XXX-YYY中的XXX） addr = strtoul(pch, NULL, 16); break; &#125; &#125; fclose(fp); return addr;&#125; 在Android6.0中，在hook.c文件中添加soinfo的结构体定义:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 typedef struct link_map_t &#123; uintptr_t l_addr; char* l_name; uintptr_t l_ld; struct link_map_t* l_next; struct link_map_t* l_prev;&#125; link_map_t;typedef void (*linker_function_t)();#define SOINFO_NAME_LEN 128typedef struct soinfo &#123; char name[SOINFO_NAME_LEN]; const Elf32_Phdr* phdr; size_t phnum; Elf32_Addr entry; Elf32_Addr base; unsigned size; uint32_t unused1; // DO NOT USE, maintained for compatibility. Elf32_Dyn* dynamic; uint32_t unused2; // DO NOT USE, maintained for compatibility uint32_t unused3; // DO NOT USE, maintained for compatibility struct soinfo* next; unsigned flags; const char* strtab; Elf32_Sym* symtab; size_t nbucket; size_t nchain; unsigned* bucket; unsigned* chain; //------------------ // This is only used by 32-bit MIPS, but needs to be here for // all 32-bit architectures to preserve binary compatibility. unsigned* plt_got; Elf32_Rel* plt_rel; size_t plt_rel_count; Elf32_Rel* rel; size_t rel_count; linker_function_t* preinit_array; size_t preinit_array_count; linker_function_t* init_array; size_t init_array_count; linker_function_t* fini_array; size_t fini_array_count; linker_function_t init_func; linker_function_t fini_func; // ARM EABI section used for stack unwinding. unsigned* ARM_exidx; size_t ARM_exidx_count; size_t ref_count; link_map_t link_map; int constructors_called; // When you read a virtual address from the ELF file, add this // value to get the corresponding address in the process' address space. Elf32_Addr load_bias;&#125; soinfo;uint32_t load_bias_addr; 并修改get_module_base的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748uint32_t get_module_base(pid_t pid, const char *module_path)&#123; FILE *fp = NULL; char *pch = NULL; char filename[32]; char line[512]; uint32_t addr = 0; void *handle = dlopen( LIBSF_PATH, RTLD_GLOBAL); soinfo *si = (soinfo*)handle; addr = si-&gt;base; load_bias_addr = si-&gt;load_bias; //若pid为负值，proc/self/maps是查找本进程的内存映射信息 //snprintf()对filename字串赋值 if ( pid &lt; 0 ) snprintf(filename, sizeof(filename), \"/proc/self/maps\"); //若pid为非负值，proc/pid/maps查找指定pid进程的内存映射信息 else snprintf(filename, sizeof(filename), \"/proc/%d/maps\", pid); //处理打开内存文件失败 if ( (fp = fopen(filename, \"r\")) == NULL ) &#123; LOGE(\"open %s failed!\", filename); return 0; &#125; //逐行读取内存文件maps while ( fgets(line, sizeof(line), fp) ) &#123; //如果在maps文件中搜索在module_path字符串（模块名称？） if ( strstr(line, module_path) ) &#123; LOGE(\"[+]:2\"); //strtok()把字串line按\"-\"分割，返回被分割出字符串的指针 pch = strtok(line, \"-\"); //strtoul()把字串pch转换成16进制 //此处addr为模块所处内存空间的起始地址（XXX-YYY中的XXX） addr = strtoul(pch, NULL, 16); break; &#125; &#125; fclose(fp); return addr;&#125; 2.Inline hook(inlineHook.c)在Android5.0中，其中find_name(参考文章点这里)的代码如下：12345678910111213141516171819202122232425262728293031323334353637int find_name(pid_t pid, char *name, char *libn, unsigned long *addr)&#123; struct mm mm[1000]; unsigned long libcaddr; int nmm; char libc[1024]; symtab_t s; if (0 &gt; load_memmap(pid, mm, &amp;nmm)) &#123; log(\"[-] cannot read memory map\\n\") return -1; &#125; else log(\"[+] success load memory map\") if (0 &gt; find_libname(libn, libc, sizeof(libc), &amp;libcaddr, mm, nmm)) &#123; log(\"[-] cannot find lib: %s\\n\", libn) return -1; &#125; else log(\"[+] success find lib name: 0x%X\", libcaddr) log(\"[+] lib: &gt;%s&lt;\\n\", libc) s = load_symtab(libc); if (!s) &#123; log(\"[-] cannot read symbol table\\n\") return -1; &#125;else log(\"[+] success read symbol table\") if (0 &gt; lookup_func_sym(s, name, addr)) &#123; log(\"[-] cannot find function: %s\\n\", name) return -1; &#125;else log(\"[+] success find function: %s: addr - 0x%X, *addr - 0x%X\", name, addr, *addr) *addr += libcaddr; return 0;&#125; 在Android6.0中，在inlineHook.c文件中同样添加上述soinfo的结构体定义，并修改find_name函数为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int find_name(pid_t pid, char *name, char *libn, unsigned long *addr, int syslib)&#123; struct mm mm[1000]; unsigned long libcaddr; int nmm; char libc[1024]; symtab_t s; if (0 &gt; load_memmap(pid, mm, &amp;nmm)) &#123; log(\"[-] cannot read memory map\\n\") return -1; &#125; else log(\"[+] success load memory map\") if (0 &gt; find_libname(libn, libc, sizeof(libc), &amp;libcaddr, mm, nmm)) &#123; log(\"[-] cannot find lib: %s\\n\", libn) return -1; &#125; else log(\"[+] success find lib name: 0x%X\", libcaddr) log(\"[+] lib: &gt;%s&lt;\\n\", libc) s = load_symtab(libc); if (!s) &#123; log(\"[-] cannot read symbol table\\n\") return -1; &#125;else log(\"[+] success read symbol table\") if (0 &gt; lookup_func_sym(s, name, addr)) &#123; log(\"[-] cannot find function: %s\\n\", name) return -1; &#125;else log(\"[+] success find function: %s: addr - 0x%X, *addr - 0x%X\", name, addr, *addr) log(\"[+] libcaddr is 0x%X\\n\", libcaddr) void *handle = dlopen( LIBSF_PATH, RTLD_GLOBAL); soinfo *si = (soinfo*)handle; load_bias_addr = si-&gt;load_bias; log(\"[+] load_bias_addr is 0x%X\\n\", load_bias_addr) if(syslib == 0)&#123; *addr += libcaddr; &#125;else if(syslib == 1)&#123; *addr += load_bias_addr; &#125;else&#123; log(\"[-] parameter syslib is wrong !\\n\") &#125; return 0;&#125; 源码之后整理一下会放出来，有什么问题可以直接来问我~","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"},{"name":"ADBI","slug":"ADBI","permalink":"https://skylinelulu.github.io/tags/ADBI/"}]},{"title":"xposed中函数参数byte[]类型数据读取","slug":"xposed-byte[]","date":"2018-06-03T03:07:02.000Z","updated":"2018-06-03T07:02:04.863Z","comments":true,"path":"2018/06/03/xposed-byte[]/","link":"","permalink":"https://skylinelulu.github.io/2018/06/03/xposed-byte[]/","excerpt":"","text":"之前hook native函数是使用ADBI框架的，但是其平台有限，Android5效果稳定，Android6成功率不高，到Android7就无法使用了。由于xposed（已支持Android8）也可以Hook native函数，可获取native函数的参数数据，因此想将hook的函数从ADBI框架移植到xposed模块中。但是遇到了一个问题：之前使用ADBI框架获取byte[]类型的参数数据是正常的，但是在xposed中只能获取到地址，一直提示参数为object类型。那么如何在xposed中获得真实数据呢？解决方案参考如下。 如下为ADBI框架中重写的函数，获取byte类型参数a的数据，并写入/sdcard/data.txt中。 123456789101112131415161718192021222324void new_hookData(JNIEnv* env, jobject thiz, jbyte *a) &#123; jbyte *arrayBody = (*env)-&gt;GetByteArrayElements(env,a,NULL); jsize len = (*env)-&gt;GetArrayLength(env,a); byte *dDate = (byte *)arrayBody; int fd = open(\"/sdcard/data.txt\", O_APPEND|O_RDWR|O_CREAT,S_IRWXU); if(fd &lt; 0) &#123; LOGI(\"[+] open failed\"); LOGW(\"[+] error (errno=%d)\", errno); &#125; else &#123; LOGI(\"[+] success open\"); &#125; int write_len = write(fd, dDate, len); (*env)-&gt;ReleaseByteArrayElements(env,a,arrayBody,NULL); close(fd); old_hookData(env, thiz, a);&#125; 如下是xposed中的hook代码： 1234567891011121314151617181920212223findAndHookMethod(\"className\",lp.classLoader,\"methodName\",byte[].class, new hookData());class hookData extends XC_MethodHook&#123; protected void beforeHookedMethod(MethodHookParam param) throws Throwable &#123; byte[] buf = (byte[])param.args[0]; FileHelper filehelper = new FileHelper(); try &#123; //将byte数组写入文件 createFile(\"/sdcard/data.txt\", buf); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; //将byte数组写入文件 public void createFile(String path, byte[] content) throws IOException &#123; FileOutputStream fos = new FileOutputStream(path); fos.write(content); fos.close(); &#125;&#125; over!","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"hook","slug":"hook","permalink":"https://skylinelulu.github.io/tags/hook/"},{"name":"xposed","slug":"xposed","permalink":"https://skylinelulu.github.io/tags/xposed/"}]},{"title":"Android Permission Unleashed","slug":"Android Permissions Unleashed","date":"2018-05-31T10:02:17.000Z","updated":"2018-06-03T07:54:21.216Z","comments":true,"path":"2018/05/31/Android Permissions Unleashed/","link":"","permalink":"https://skylinelulu.github.io/2018/05/31/Android Permissions Unleashed/","excerpt":"","text":"《Android permissions unleashed》来源：CSF 2015关键词：定理证明器，Android权限模型，策略摘要： 本文利用定力证明器为Android权限建模，将组件的权限定制成策略集合，提出了两个概念：一个是组件栈（Component stack），由frame组成,而frame F = { C, P, Φ }，其中， C为component，P为权限集，Φ为策略集。第二个是系统配置，由组件栈组成，Σ = [S1; S2; . . .]；针对frame，stack和configuration制了相应的策略范围direct,local和global；将example中的权限与上述结合，构建了权限、组件和策略的逻辑表达。","categories":[{"name":"Paper","slug":"Paper","permalink":"https://skylinelulu.github.io/categories/Paper/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"permission","slug":"permission","permalink":"https://skylinelulu.github.io/tags/permission/"}]},{"title":"三星s7 edge(G9350)刷机经验","slug":"SUMSUNG-ROOT","date":"2018-05-12T13:09:32.000Z","updated":"2018-06-03T07:11:27.348Z","comments":true,"path":"2018/05/12/SUMSUNG-ROOT/","link":"","permalink":"https://skylinelulu.github.io/2018/05/12/SUMSUNG-ROOT/","excerpt":"","text":"设备：Sumsung S7 Edge刷入系统: Android 7刷机方式：线刷需要安装包： 链接：https://pan.baidu.com/s/1N8U0KFikiGz_QFnfC9EUQg 密码：vuy0 步骤：1.刷系统。电脑端打开odin刷机软件。手机关机情况下，同时按住“音量键下”+“HOME键”+“开机键”进入开机模式，按照提示按下音量上键。按照顺序刷入五件套，即S7android7.0文件夹中的文件。具体教程2.解锁。进入系统，运行“三星解锁.apk”，进行解锁。3.ROOT（参考：7.0ROOT步骤.txt）。再次关机，同时按住“音量键下”+“HOME键”+“开机键”进入开机模式，打开odin，AP刷入recovery，即G9350_7.0_QC1_twrp_kernel_su2.79.tar文件。在odin的options中去掉Auto Reboot的对勾。start。手机进入twrp模式，清除，格式化data分区，输入yes，重启手机。备注：查看设置-关于手机-软件信息-版本号，我的手机的版本号后三位为QC1，因此采用该recovery文件。 开机，adb shell, su，就可以看到设备已经ROOT，data也解密了。","categories":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://skylinelulu.github.io/tags/Android/"},{"name":"Sumsung Root","slug":"Sumsung-Root","permalink":"https://skylinelulu.github.io/tags/Sumsung-Root/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-12T12:14:09.851Z","updated":"2018-06-24T08:26:42.734Z","comments":true,"path":"2018/05/12/hello-world/","link":"","permalink":"https://skylinelulu.github.io/2018/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}